power_prosp_tau2 =  sum(res_prosp_tau2) / M)
return(res)
}
f_power(n = 50)
rm(list=ls())
library(nloptr)
# Consider a simple case
# The treatment assignment for the RPCT data is completely at random
# There is no unmeasured confounders
M <- 2000
tau <- 0.8
# Step 1:
{
# Generate outcome Y based on linear regression in EC data
f_gen_EC_Y <- function(x,
beta0,
beta1,
sdY){
mu <- beta0 + beta1 * x
return(rnorm(1, mean = mu, sd = sdY))
}
# Generate EC data
f_gen_EC <- function(seed_EC = 123,
N_EC = 1000,
muX_EC = 1,
sdX_EC = 1,
beta0 = 1,
beta1 = 2,
sdY = 1){
set.seed(seed_EC)
# generate the pre-treatment covariates
X_EC <- rnorm(N_EC, mean = muX_EC, sd = sdX_EC)
Y_EC <- mapply(f_gen_EC_Y,
x = X_EC,
beta0,
beta1,
sdY)
return(data.frame(A = rep(0, N_EC), X = X_EC, Y = Y_EC))
}
# Generate outcome Y based on linear regression in RCT data
f_gen_RCT_Y <- function(x,
a,
beta0,
beta1,
tau,
sdY){
mu <- beta0 + beta1 * x + tau * a
return(rnorm(1, mean = mu, sd = sdY))
}
# Generate RCT data
f_gen_RCT <- function(seed = 123,
N_RCT, # sample size of RCT data
pi_A, # propensity score in RCT
muX_RCT = 1,
sdX_RCT = 1,
beta0 = 1,
beta1 = 2,
sdY = 1,
tau
){
set.seed(seed)
N_trt <- floor(N_RCT * pi_A) + 1
N_crl <- N_RCT - N_trt
# generate the pre-treatment covariates
X_RCT <- rnorm(N_RCT, mean = muX_RCT, sd = sdX_RCT)
# generate A by using pi
A_trt <- rep(1, N_trt)
A_crl <- rep(0, N_crl)
A <- c(A_trt, A_crl)
Y_RCT <- mapply(f_gen_RCT_Y,
x = X_RCT,
a = A,
beta0, beta1, tau, sdY)
return(data.frame(A = A, X = X_RCT, Y = Y_RCT))
}
# combine data_RCT and data_EC
f_gen_full <- function(data_EC,
data_RCT){
data_full <- rbind(data_RCT, data_EC)
data_full$R <- c(rep(1, nrow(data_RCT)), rep(0, nrow(data_EC)) )
return(data_full)
}
data_EC <- f_gen_EC(N_EC = 1000)
data_RCT <- f_gen_RCT(N_RCT = 200)
data_full <-  f_gen_full(data_EC, data_RCT)
}
# Generate outcome Y based on linear regression in EC data
f_gen_EC_Y <- function(x,
beta0,
beta1,
sdY){
mu <- beta0 + beta1 * x
return(rnorm(1, mean = mu, sd = sdY))
}
# Generate EC data
f_gen_EC <- function(seed_EC = 123,
N_EC = 1000,
muX_EC = 1,
sdX_EC = 1,
beta0 = 1,
beta1 = 2,
sdY = 1){
set.seed(seed_EC)
# generate the pre-treatment covariates
X_EC <- rnorm(N_EC, mean = muX_EC, sd = sdX_EC)
Y_EC <- mapply(f_gen_EC_Y,
x = X_EC,
beta0,
beta1,
sdY)
return(data.frame(A = rep(0, N_EC), X = X_EC, Y = Y_EC))
}
# Generate outcome Y based on linear regression in RCT data
f_gen_RCT_Y <- function(x,
a,
beta0,
beta1,
tau,
sdY){
mu <- beta0 + beta1 * x + tau * a
return(rnorm(1, mean = mu, sd = sdY))
}
# Generate RCT data
f_gen_RCT <- function(seed = 123,
N_RCT, # sample size of RCT data
pi_A, # propensity score in RCT
muX_RCT = 1,
sdX_RCT = 1,
beta0 = 1,
beta1 = 2,
sdY = 1,
tau
){
set.seed(seed)
N_trt <- floor(N_RCT * pi_A) + 1
N_crl <- N_RCT - N_trt
# generate the pre-treatment covariates
X_RCT <- rnorm(N_RCT, mean = muX_RCT, sd = sdX_RCT)
# generate A by using pi
A_trt <- rep(1, N_trt)
A_crl <- rep(0, N_crl)
A <- c(A_trt, A_crl)
Y_RCT <- mapply(f_gen_RCT_Y,
x = X_RCT,
a = A,
beta0, beta1, tau, sdY)
return(data.frame(A = A, X = X_RCT, Y = Y_RCT))
}
# combine data_RCT and data_EC
f_gen_full <- function(data_EC,
data_RCT){
data_full <- rbind(data_RCT, data_EC)
data_full$R <- c(rep(1, nrow(data_RCT)), rep(0, nrow(data_EC)) )
return(data_full)
}
# Use the formula provided in Chenyin's paper
f_r <- function(data,
N_R,
N_E,
mu1_model,
mu0_model){
data_10_r <- filter(data, R == 1 & A == 0)
epsi_10_r <- data_10_r$Y -  predict(mu0_model, data_10_r)
data_0_r <- filter(data, R == 0)
epsi_0_r <- data_0_r$Y -  predict(mu0_model, data_0_r)
res <- 1 / N_R * sum(epsi_10_r^2) /
(1 / N_E * sum(epsi_0_r^2) )
return(res)
}
# Variance estimation based on EC data
Est_var_simple <- function(
data_EC, # available EC data
N_RCT, # sample size of RCT, need to be decided
r = 1, # the ratio of variance in EC and variance in control of RCT
d_X = 1, # the ratio of f(X|R=1) with f(X|R=0)
pi = 0.5, # given propensity score
gamma1 = 1 # the ratio of two kappa
# var_fun = var_fun # given function to estimate variance
){
# Step 0: given propensity score function - skip, let's use 1/2
# Step 1: estimate V(Y|X,R=0) using data_EC
# var_X_EC <- var_fun(data_EC)
var_X_EC <- sd(data_EC$X)^2
# Step 2: estimate V(Y|X,R=1,A=0)
var_X_RCT_0 <- r * var_X_EC
# Step 3: estimate kappa 0 and kappa 1
kappa_0 <- mean(var_X_RCT_0)
kappa_1 <- gamma1 * kappa_0
# Step 4: estimate V(Y|R=1,A=1), V(Y|R=1, A=0)
#  Step 4 relies on the d(X) function
var_EC <- var(data_EC$Y)
var_RCT_0 <- var_EC
var_RCT_1 <- var_EC
# Step 5: calculate d(X) - skip, let's use the true value
# Step 6: plug in to get nu^2
N_EC <- nrow(data_EC)
N <- N_EC + N_RCT
r_R <- N_RCT / N_EC
term1 <- 1 / N_RCT / pi * mean(var_X_RCT_0)
term2 <- 1 / N_RCT * (var_EC -  mean(var_X_RCT_0))
term3 <- 1 / N_RCT * mean(r * (1 - pi)/(1 - pi + r / d_X / r_R)^2 * var_X_EC)
term4 <- 1 / N_RCT * (var_EC - mean(var_X_RCT_0))
term5 <- 1 / N_RCT * mean(r^2/r_R/(1 - pi + r / d_X / r_R)^2 * var_X_EC)
nu2 <- N * (term1 + term2 + term3 + term4 + term5)
return(nu2)
}
# Point estimation
f_est <- function(data = data_full){
R <- data$R
A <- data$A
X <- data$X
Y <- data$Y
data_11 <- filter(data,  R == 1 & A == 1)
mu1_model <- lm(Y ~ X, data_11)
data_10 <- filter(data,  R == 1 & A == 0)
mu0_model <- lm(Y ~ X, data_10)
data_1 <- filter(data, R == 1)
pi_A_model <- glm(A ~ X, data_1, family = "binomial")
pi_R_model <- glm(R ~ X, data, family = "binomial")
data_0 <- filter(data, R == 0)
N_R <- nrow(data_1)
N_E <- nrow(data_0)
mu1_X <- predict(mu1_model, data)
mu0_X <- predict(mu0_model, data)
pi_A_X <- predict(pi_A_model, data, type = "response")
pi_R_X <- predict(pi_R_model, data, type = "response")
epsi_1 <- data$Y - mu1_X
epsi_0 <- data$Y - mu0_X
q_X <- pi_R_X / (1 - pi_R_X)
r_X <- f_r(data,
N_R,
N_E,
mu1_model,
mu0_model)
r_R <- N_R / N_E
N <- N_R + N_E
## Point estimation - based on IF
{
IF_part1 <- (N_R + N_E) / N_R * (data$R * (mu1_X - mu0_X + data$A * epsi_1 / pi_A_X ))
IF_part2 <- (N_R + N_E) / N_R * (
(data$R * (1- data$A) + (1 - data$R) * r_X) * (q_X * epsi_0) / (q_X * (1 - pi_A_X) + r_X)
)
IF <- IF_part1 - IF_part2
IF_est_tau <- mean(IF)
IF_est_tau
}
## Point estimation - old version
{
# # part 1
# mu1_1 <- predict(mu1_model, data_1)
# mu0_1 <- predict(mu0_model, data_1)
# epsi_11 <- data_11$Y - predict(mu1_model, data_11)
# pi_A_11 <- predict(pi_A_model, data_11, type = "response")
#
# part1 <- 1 / N_R * sum(mu1_1 - mu0_1) + 1 / N_R * sum(epsi_11 / pi_A_11)
#
#
# # part 2-1
# P_R_10 <- predict(pi_R_model, data_10, type = "response")
# pi_A_10 <- predict(pi_A_model, data_10, type = "response")
# epsi_10 <- data_10$Y -  predict(mu0_model, data_10)
# r_10 <- r_X
#
#
# # part 2-2
# P_R_0 <- predict(pi_R_model, data_0, type = "response")
# epsi_0 <- data_0$Y -  predict(mu0_model, data_0)
# pi_A_0 <-  predict(pi_A_model, data_0, type = "response")
# r_0 <- r_X
#
# part2 <- 1 / N_R * sum( (P_R_10 / (1 - P_R_10) * epsi_10) / (P_R_10 / (1 - P_R_10)  * (1 - pi_A_10) + r_10) ) +
#   1 / N_R * sum((r_0 * P_R_0 / (1 - P_R_0) *  epsi_0) / (P_R_0 / (1 - P_R_0) * ( 1 - pi_A_0) + r_0 ))
#
# est_tau <- part1 - part2
#
# est_tau
}
## Variance estimation - based on IF
{
IF_est_var <- mean(IF^2)
}
## Variance estimation 0 based on formula
{
var11_X <- 1 / N_R * sum(data$R * data$A * (data$Y - mu1_X)^2)
var10_X <- 1 / N_R * sum(data$R * (1 - data$A) * (data$Y - mu0_X)^2)
var11 <- sd(data_11$Y)^2
var10 <- sd(data_10$Y)^2
var0 <- sd(data_0$Y)^2
kappa1 <- var11_X
kappa0 <- var10_X
# part 1
part1_var <- 1 / N_R * mean(data$R * var11_X / pi_A_X)
# part 2
part2_var <- 1 / N_R * (var11 - kappa1)
# part 3
part3_var <- 1 / N_R * mean(data$R * var10_X * (1 - pi_A_X) / ((1 - pi_A_X) + r_X / q_X)^2)
# part 4
part4_var <- 1 / N_R * (var10 - kappa0)
# part 5
part5_var <- 1 / N_R * mean((1 - data$R) * var0 * r_X^2 /r_R / ((1 - pi_A_X) + r_X / q_X)^2 )
est_nu2 <- N * (part1_var + part2_var + part3_var + part4_var + part5_var )
}
## Prospective estimator
{
est_prosp_nu2 <- Est_var_simple(data_0,
N_RCT = N_R)
}
return(data.frame(IF_est_tau,
IF_est_var,
est_nu2,
est_prosp_nu2))
}
M <- 2000
tau <- 0.8
pi_A <- 0.5
n <- 30
M <- 2000
tau <- 0.8
pi_A <- 0.5
f_power(n = 50,
pi_A = pi_A,
tau = tau,
M = M,
N_EC = 1000,
alpha = 0.05)
f_power <- function(n,
pi_A = pi_A,
tau = tau,
M = M,
N_EC = 1000,
alpha = 0.05
){
N <- N_EC + n
set.seed(567)
Index_all <- sample(1:50000000, M, replace=F)
Result_05_124 <- c()
# start <- Sys.time()
for(i in 1:M){
print(i)
data_EC <- f_gen_EC(seed_EC = Index_all[i],
N_EC = N_EC)
data_RCT <- f_gen_RCT(seed = Index_all[i],
N_RCT = n,
pi_A = pi_A,
tau = tau)
data_full <-  f_gen_full(data_EC, data_RCT)
res1 <- f_est(data_full)
Result_05_124 <- rbind(Result_05_124, res1)
}
# end <- Sys.time()
# end - start
Z_IF_var <- (Result_05_124$IF_est_tau - 0) / sqrt(Result_05_124$IF_est_var / N)
res_IF_var <- (abs(Z_IF_var) > qnorm(1 - alpha/2)) * 1
Z_tau2 <- (Result_05_124$IF_est_tau - 0) / sqrt(Result_05_124$est_nu2 / N)
res_tau2 <- (abs(Z_tau2) > qnorm(1 - alpha/2)) * 1
Z_prosp_tau2 <- (Result_05_124$IF_est_tau - 0) / sqrt(Result_05_124$est_prosp_nu2 / N)
res_prosp_tau2 <- (abs(Z_prosp_tau2) > qnorm(1 - alpha/2)) * 1
res <- data.frame(power_IF_var = sum(res_IF_var) / M,
power_tau2 = sum(res_tau2) / M,
power_prosp_tau2 =  sum(res_prosp_tau2) / M)
return(res)
}
f_power(n = 50,
pi_A = pi_A,
tau = tau,
M = M,
N_EC = 1000,
alpha = 0.05)
j=1
n_list <- seq(5, 300, by = 5)
n <- n_list[j]
temp <-  f_power(n = n,
pi_A = pi_A,
tau = tau,
M = M,
N_EC = 1000,
alpha = 0.05)
temp
n_list <- seq(2, 200, by = 2)
system.time( temp <-  f_power(n = n,
pi_A = pi_A,
tau = tau,
M = M,
N_EC = 1000,
alpha = 0.05))
n_list <- seq(2, 200, by = 2) # length = 100
Res <- c()
for(j in 1:length(n_list)){
n <- n_list[j]
temp <-  f_power(n = n,
pi_A = pi_A,
tau = tau,
M = M,
N_EC = 1000,
alpha = 0.05)
Res <- rbind(Res, temp)
}
n_list <- seq(2, 200, by = 2) # length = 100
Res <- c()
for(j in 1:length(n_list)){
n <- n_list[j]
temp <-  f_power(n = n,
pi_A = pi_A,
tau = tau,
M = M,
N_EC = 1000,
alpha = 0.05)
Res <- rbind(Res, temp)
}
n_list <- seq(2, 200, by = 2) # length = 100
j=1
n <- n_list[j]
n
temp <-  f_power(n = n,
pi_A = pi_A,
tau = tau,
M = M,
N_EC = 1000,
alpha = 0.05)
j=1
n_list <- seq(4, 200, by = 2) # length = 100
n <- n_list[j]
n
temp <-  f_power(n = n,
pi_A = pi_A,
tau = tau,
M = M,
N_EC = 1000,
alpha = 0.05)
n_list <- seq(4, 200, by = 2) # length = 100
Res <- c()
for(j in 1:length(n_list)){
n <- n_list[j]
temp <-  f_power(n = n,
pi_A = pi_A,
tau = tau,
M = M,
N_EC = 1000,
alpha = 0.05)
Res <- rbind(Res, temp)
}
getwd()
Res
setwd("C:/Users/gaoyuji/OneDrive - Merck Sharp & Dohme LLC/Documents/GitHub/hybrid_design/R code")
saveRDS(Res, "res_05_08.RData")
setwd("C:/Users/gaoyuji/OneDrive - Merck Sharp & Dohme LLC/Documents/GitHub/hybrid_design/R code")
Res <- resRDS("res_05_08.RData")
setwd("C:/Users/gaoyuji/OneDrive - Merck Sharp & Dohme LLC/Documents/GitHub/hybrid_design/R code")
Res <- readRDS("res_05_08.RData")
head(Res)
Res_plot <-  Res %>%
pivot_longer(
cols = "power_IF_var":"power_prosp_tau2",
names_to = "Estimator",
values_to = "power"
)
head(Res)
Res_plot$Estimator <- factor(Res_plot$Estimator,
levels = c("power_IF_var",
"power_tau2",
"power_prosp_tau2"
))
n_list <- seq(4, 200, by = 2)
Res$n <- n_list
setwd("C:/Users/gaoyuji/OneDrive - Merck Sharp & Dohme LLC/Documents/GitHub/hybrid_design/R code")
saveRDS(Res, "res_05_08.RData")
setwd("C:/Users/gaoyuji/OneDrive - Merck Sharp & Dohme LLC/Documents/GitHub/hybrid_design/R code")
Res <- readRDS("res_05_08.RData")
Res_plot <-  Res %>%
pivot_longer(
cols = "power_IF_var":"power_prosp_tau2",
names_to = "Estimator",
values_to = "power"
)
View(Res_plot)
Res_plot$Estimator <- factor(Res_plot$Estimator,
levels = c("power_IF_var",
"power_tau2",
"power_prosp_tau2"
))
View(Res_plot)
setwd("C:/Users/gaoyuji/OneDrive - Merck Sharp & Dohme LLC/Documents/GitHub/hybrid_design/R code")
Res <- readRDS("res_05_08.RData")
Res_plot <-  Res %>%
pivot_longer(
cols = "power_IF_var":"power_prosp_tau2",
names_to = "estimator",
values_to = "power"
)
Res_plot$estimator <- factor(Res_plot$estimator,
levels = c("power_IF_var",
"power_tau2",
"power_prosp_tau2"
))
p1 <- ggplot(data = Res_plot, aes(x = n, y = power, group = estimator)) +
geom_line()+
geom_hline(yintercept=mean(Abs_bias_tau11_box_PP$absolute_bias, na.rm = T),
linetype="dashed",
color = "red",
size = 1)+
labs(title="Absolute Bias for Each Estimator in Always-adherence Strata")
p1 <- ggplot(data = Res_plot, aes(x = n, y = power, group = estimator)) +
geom_line()+
# geom_hline(yintercept=mean(Abs_bias_tau11_box_PP$absolute_bias, na.rm = T),
#            linetype="dashed",
#            color = "red",
#            size = 1)+
labs(title="Absolute Bias for Each Estimator in Always-adherence Strata")
p1
setwd("C:/Users/gaoyuji/OneDrive - Merck Sharp & Dohme LLC/Documents/GitHub/hybrid_design/R code")
saveRDS(Res, "res_05_08_part1.RData")
View(Res)
